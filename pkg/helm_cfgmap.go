package x

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/golang/protobuf/ptypes/any"
	"k8s.io/api/core/v1"
	"k8s.io/helm/pkg/proto/hapi/chart"
	"k8s.io/helm/pkg/timeconv"
	"sigs.k8s.io/yaml"
	"strconv"
	"time"

	rspb "k8s.io/helm/pkg/proto/hapi/release"
)

func TurnHelmTemplateToInstall(chartName, version, tillerNs, releaseName, ns, manifest string) (string, error) {
	man, hooks, err := SplitManifestAndHooks(manifest)
	if err != nil {
		return "", err
	}
	manifestData := []byte(base64.StdEncoding.EncodeToString([]byte(man)))
	vData := []byte(base64.StdEncoding.EncodeToString([]byte("This release is generated by helm-x")))
	templates := []*chart.Template{
		{
			Name: "templates/all.yaml",
			Data: manifestData,
		},
	}
	c := &chart.Chart{
		Metadata: &chart.Metadata{
			Name:       chartName,
			ApiVersion: "v1",
			AppVersion: version,
		},
		Templates:    templates,
		Values:       &chart.Config{Raw: ""},
		Dependencies: []*chart.Chart{},
		Files: []*any.Any{
			{
				TypeUrl: "README.md",
				Value:   vData,
			},
		},
	}

	ts := timeconv.Now()
	// See `kubectl get configmap -n kube-system -o jsonpath={.data.release} foo.v1 | base64 -D  | gunzip -` for
	// real-world examples
	release := &rspb.Release{
		Chart: c,
		Info: &rspb.Info{
			FirstDeployed: ts,
			LastDeployed:  ts,
			Status:        &rspb.Status{},
			Description:   fmt.Sprintf("Adopted with helm-x"),
		},
		Hooks:    hooks,
		Config:   &chart.Config{Raw: ""},
		Manifest: man,
	}
	release.Name = releaseName
	release.Namespace = ns
	release.Info.Status.Code = rspb.Status_DEPLOYED
	// Starts from "1". Try installing any chart and see by running `helm install --name foo yourchart && kubectl -n kube-system get configmap -o yaml foo.v1`
	release.Version = 1

	cfgmap, err := ReleaseToConfigMap(release)
	if err != nil {
		return "", err
	}

	// Can't we automatically set these?
	cfgmap.APIVersion = "v1"
	cfgmap.Kind = "ConfigMap"
	cfgmap.Namespace = tillerNs

	/// Turn cfgmap to yaml

	cfgmapBytes, err := json.Marshal(cfgmap)
	if err != nil {
		return "", err
	}

	yamlBytes, err := yaml.JSONToYAML(cfgmapBytes)
	if err != nil {
		return "", err
	}

	concatenated := man + "\n---\n" + string(yamlBytes)

	return concatenated, nil
}

func ReleaseToConfigMap(release *rspb.Release) (*v1.ConfigMap, error) {
	var lbs labels

	lbs.init()
	lbs.set("CREATED_AT", strconv.Itoa(int(time.Now().Unix())))

	key := makeKey(release.Name, release.Version)

	return newConfigMapsObject(key, release, lbs)
}
