package releasetool

import (
	"encoding/base64"
	"fmt"
	"github.com/golang/protobuf/ptypes/any"
	"k8s.io/helm/pkg/kube"
	"k8s.io/helm/pkg/proto/hapi/chart"
	rspb "k8s.io/helm/pkg/proto/hapi/release"
	"k8s.io/helm/pkg/storage"
	"k8s.io/helm/pkg/storage/driver"
	"k8s.io/helm/pkg/timeconv"

	// Required because go mod doesn't handle this transitive dep of helm
	// and results in `kube.New(nil).KubernetesClientSet()` to fail compiling on missing KubernetesClientSet()
	"k8s.io/kubernetes/pkg/kubectl/cmd/util"
)

// ReleaseTool operates on Helm releases like ReleaseModule, but has only a few operations supported to make helm-x work.
// For the upstream "ReleaseModule", see https://github.com/helm/helm/blob/53d432fa58748412ff3dc10bc27cbf996d96c3ed/pkg/tiller/release_modules.go
type ReleaseTool struct {
	driver *storage.Storage
}

func goModWorkaround() error {
	return util.ErrExit
}

func NewSecretBackednReleaseTool(tillerNs string) (*ReleaseTool, error) {
	clientset, err := kube.New(nil).KubernetesClientSet()
	if err != nil {
		return nil, fmt.Errorf("Cannot initialize Kubernetes connection: %s", err)
	}

	secrets := driver.NewSecrets(clientset.CoreV1().Secrets(tillerNs))

	storage := storage.Init(secrets)

	return &ReleaseTool{
		driver: storage,
	}, nil
}

type Opts struct {
	StorageBackend string
}

func New(tillerNs string, opts ...Opts) (*ReleaseTool, error) {
	if len(opts) == 1 && opts[0].StorageBackend == "secrets" {
		return NewSecretBackednReleaseTool(tillerNs)
	}
	return NewConfigMapBackedReleaseTool(tillerNs)
}

func NewConfigMapBackedReleaseTool(tillerNs string) (*ReleaseTool, error) {
	clientset, err := kube.New(nil).KubernetesClientSet()
	if err != nil {
		return nil, fmt.Errorf("Cannot initialize Kubernetes connection: %s", err)
	}

	cmClient := clientset.CoreV1().ConfigMaps(tillerNs)
	cfgmaps := driver.NewConfigMaps(cmClient)

	storage := storage.Init(cfgmaps)

	return &ReleaseTool{
		driver: storage,
	}, nil
}

func (s *ReleaseTool) GetLatestRelease(name string) (*rspb.Release, error) {
	return s.driver.Last(name)
}

func (s *ReleaseTool) AdoptRelease(name, ns, manifest string) error {
	manifestData := []byte(base64.StdEncoding.EncodeToString([]byte(manifest)))
	vData := []byte(base64.StdEncoding.EncodeToString([]byte("This release is generated by helm-x")))
	c := &chart.Chart{
		Metadata: &chart.Metadata{
			Name:       "helm-x-dummy-chart",
			ApiVersion: "v1",
			AppVersion: "0.1.0",
		},
		Templates: []*chart.Template{
			{
				Name: "templates/all.yaml",
				Data: manifestData,
			},
		},
		Values:       &chart.Config{Raw: ""},
		Dependencies: []*chart.Chart{},
		Files: []*any.Any{
			{
				TypeUrl: "README.md",
				Value:   vData,
			},
		},
	}

	ts := timeconv.Now()
	// See `kubectl get configmap -n kube-system -o jsonpath={.data.release} foo.v1 | base64 -D  | gunzip -` for
	// real-world examples
	release := &rspb.Release{
		Chart: c,
		Info: &rspb.Info{
			FirstDeployed: ts,
			LastDeployed:  ts,
			Status:        &rspb.Status{},
			Description:   fmt.Sprintf("Adopted with helm-x"),
		},
		Config:   &chart.Config{Raw: ""},
		Manifest: manifest,
	}
	release.Name = name
	release.Namespace = ns
	release.Info.Status.Code = rspb.Status_DEPLOYED
	// Starts from "1". Try installing any chart and see by running `helm install --name foo yourchart && kubectl -n kube-system get configmap -o yaml foo.v1`
	release.Version = 1

	if err := s.driver.Create(release); err != nil {
		return err
	}

	return nil
}

func (s *ReleaseTool) GetDeployedRelease(name string) (*rspb.Release, error) {
	return s.driver.Deployed(name)
}
